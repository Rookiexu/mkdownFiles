# 知识点整理 #

## java基础 ##
### 注解 ###
**元注解**
两个重要属性,一个是作用域,对应的类,字段,方法还是什么  另一个是生命周期,编译,运行还是源文件

### 异常 ###
异常氛围err 和exception

exception 分为 RuntimeException和其他..RuntimeException之外的异常我们统称为非运行时异常，类型上属于Exception类及其子类，从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException

## jvm虚拟机 ##
**jvm虚拟机运行时内存区域划分**

1. 方法区 运行时常量池  所有线程共享数据
2. 堆 所有线程共享数据
3. 程序计数器 线程隔离的数据区
4. 虚拟机栈 很多栈帧 每个有局部变量表,操作数栈,帧数据区  线程隔离的数据区
5. 本地方法栈  线程隔离的数据区

**程序计数器**  
概述：较小的内存空间，为当前线程执行的字节码的行号指示器  
作用：通过改变计数器的值来指定下一条需要执行的字节码指令，来恢复中断前程序运行的位置  

特点：

1. 线程私有化，每个线程都有独立的程序计数器
2. 无内存溢出

**Java虚拟机栈**  
概述：每个方法从调用直到执行的过程，对应着一个栈帧在虚拟机栈的入栈和出栈的过程  
作用：每个方法执行都创建一个“栈帧”来存储局部变量表、操作数栈、动态链接、方法出口等信息 
 
特点：    

1. 线程私有化  
2. 生命周期与线程执行结束相同

**堆**  
创建时间：JVM启动时创建该区域  
占用空间：Java虚拟机管理内存最大的一块区域  
作用：用于存放对象实例及数组（所有new的对象）  
  
特点：  

1. 垃圾收集器作用该区域，回收不使用的对象的内存空间
2. 各个线程共享的内存区域
3. 该区域的大小可通过参数设置

**方法区**  
作用：用于存储类信息、常量、静态变量、是各个线程共享的内存区域

## 垃圾回收 ##

### 判断对象是否存活 ###
判断Java中对象存活的算法
1.引用计数器算法：
引用计数器算法是给每个对象设置一个计数器，当有地方引用这个对象的时候，计数器+1，当引用失效的时候，计数器-1，当计数器为0的时候，JVM就认为对象不再被使用，是“垃圾”了。
引用计数器实现简单，效率高；但是不能解决循环引用问问题（A对象引用B对象，B对象又引用A对象，但是A,B对象已不被任何其他对象引用），同时每次计数器的增加和减少都带来了很多额外的开销，所以在JDK1.1之后，这个算法已经不再使用了。
2.根搜索方法：
根搜索方法是通过一些“GCRoots”对象作为起点，从这些节点开始往下搜索，搜索通过的路径成为引用链（ReferenceChain），当一个对象没有被GCRoots的引用链连接的时候，说明这个对象是不可用的。
GCRoots对象包括：

虚拟机栈（栈帧中的本地变量表）中的引用的对象。
方法区域中的类静态属性引用的对象。
方法区域中常量引用的对象。
本地方法栈中JNI（Native方法）的引用的对象。


### 垃圾回收算法 ###

**标记清除**
两个阶段,第一个阶段标记没有被引用的对象,第二个阶段清除这些对象

存在效率和空间内存碎片的问题，空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

**标记-整理算法**
区别于上就是标记之后把需要保留的移到一边,直接清除边界外的对象

效率还是不高

**复制算法**

复制算法可以解决效率问题，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块内存用完了，就将还存活着的对象复制到另一块上面，然后再把已经使用过的内存空间一次清理掉，这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可

对象多的时候复制效率会比较低

**分代收集算法**  

当前商业虚拟机都是采用分代收集算法，它根据对象存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代，然后根据各个年代的特点采用最适当的收集算法，在新生代中，每次垃圾收集都发现有大批对象死去，只有少量存活，就选用复制算法，而老年代因为对象存活率高，没有额外空间对它进行分配担保，就必须使用“标记清理”或者“标记整理”算法来进行回收。

新生代 复制  
老年代 标记整理/标记清理


**Serial垃圾收集器（单线程、复制算法）**

Serial(英文：连续)是最基本垃圾收集器，使用复制算法，曾经是 JDK1.3.1 之前新生代唯一的垃圾收集器。Serial 是一个单线程的收集器，它不但只会使用一个 CPU 或一条线程去完成垃圾收集工作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。

Serial 垃圾收集器虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，对于限定单个 CPU 环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率，因此 Serial垃圾收集器依然是 java 虚拟机运行在 Client 模式下默认的新生代垃圾收集器。

**ParNew垃圾收集器（Serial + 多线程）**  

ParNew（Parallel:平行的） 垃圾收集器其实是 Serial 收集器的多线程版本，也使用复制算法，除了使用多线程进行垃 圾收集之外，其余的行为和 Serial 收集器完全一样，ParNew 垃圾收集器在垃圾收集过程中同样也 要暂停所有其他的工作线程。

ParNew 收集器默认开启和 CPU 数目相同的线程数，可以通过-XX:ParallelGCThreads 参数来限 制垃圾收集器的线程数。

ParNew 虽然是除了多线程外和 Serial 收集器几乎完全一样，但是 ParNew 垃圾收集器是很多 java 虚拟机运行在 Server 模式下新生代的默认垃圾收集器。

**Parllel Scavenge收集器 （多线程、复制算法）**  
**Serial Old收集器（单线程标记整理算法） ** 
**Parallel Old收集器（多线程标记整理算法）  **
**CMS收集器（多线程标记清除算法）  **

### Major GC和Full GC ###
针对HotSpot VM的实现，它里面的GC其实准确分类只有两大种： Partial GC：并不收集整个GC堆的模式

Young GC：只收集young gen的GC
Old GC：只收集old gen的GC。只有CMS的concurrent collection是这个模式
Mixed GC：收集整个young gen以及部分old gen的GC。只有G1有这个模式
Full GC：收集整个堆，包括young gen、old gen、perm gen（如果存在的话）等所有部分的模式。

**出发full gc的条件**

1. system.gc方法调用方
2. 老年代空间不足
3. 方法区空间不足
4. 堆里面分配很大的对象
6. GC时出现promotion failed  晋升失败 需要晋升老年代对象需要内存大于老年代内存
7. gc出现concurrent mode failure


































*********************************
## java线程,线程池 ##
1. 线程池 有哪些,有什么特性
2. 线程 有哪些 线程状态 线程从start到运行经过的状态

## Java并发 ##

1. 用过哪些对象
1. 并发包集合实现原理
2. 并发包其他原子类实现原理
3. 并发包其他对象实现原理
4. 线程间状态同步
5. volitile的实现
6. cas的实现

## jvm虚拟机 ##
1. 内存分区
2. 年代划分
3. 有哪些gc算法,gc算法原理
4. jvm调优
5. 请介绍一下JVM内存模型??用过什么垃圾回收器都说说呗
6. 线上发送频繁full gc如何处理? CPU 使用率过高怎么办?如何定位问题?如何解决说一下解决思路和处理方法
7. 知道字节码吗?字节码都有哪些?Integer x =5,int y =5，比较x =y 都经过哪些步骤?
8. 讲讲类加载机制呗都有哪些类加载器，这些类加载器都加载哪些文件?手写一下类加载Demo
9. 知道osgi吗? 他是如何实现的???
10. 请问你做过哪些JVM优化?使用什么方法达到什么效果?
11. classforName("java.lang.String")和String classgetClassLoader() LoadClass("java.lang.String") 什么区别啊?

## Java nio ##
1. nio 底层实现
2. noi关键类
3. netty的结构
4. netty的常用设计模式
5. netty的bytebuf为什么快
6. protobuf的Java实现,protobuf为什么快

## 数据库 ##
1. mysql的调优
2. mongodb的分片
3. 索引的实现原理
4. 不同引擎的特性

## disruptor ##
1. 原理
2. 为什么快

## 定时器实现 ##
1. 有哪些现成的定时器
2. 怎么实现定时器
3. 各个方案的好处

## 分布式 ##
1. 为什么使用消息队列啊消息队列有什么优点和缺点啊?
2. 如何保证消息队列的高可用啊如何保证消息不被重复消费啊
3. kafka ，activemq,rabbitmq ，rocketmq都有什么优点，缺点啊???
4. 如果让你写一个消息队列，该如何进行架构设计啊?说一下你的思路

## 高并发高可用架构设计 ##
1. 如何设计一个高并发高可用系统
2. 如何限流?工程中怎么做的，说一下具体实现
3. 缓存如何使用的缓存使用不当会造成什么后果?
4. 如何熔断啊?熔断框架都有哪些?具体实现原理知道吗?
5. 如何降级如何进行系统拆分，如何数据库拆分????

## 分布式服务框架 ##
1. 说一下dubbo的实现过程注册中心挂了可以继续通信吗??
2. zk原理知道吗zk都可以干什么Paxos算法知道吗?说一下原理和实现??
3. dubbo支持哪些序列化协议?hessian 说一下hessian的数据结构PB知道吗为啥PB效率是最高的啊??
4. 知道netty吗'netty可以干嘛呀NIO,BIO,AIO 都是什么啊有什么区别啊?
5. dubbo复制均衡策略和高可用策略都有哪些啊动态代理策略呢?
6. 为什么要进行系统拆分啊拆分不用dubbo可以吗'dubbo和thrift什么区别啊?

## 分布式缓存 ##
1. redis和memcheched 什么区别为什么单线程的redis比多线程的memched效率要高啊?
2. redis有什么数据类型都在哪些场景下使用啊?
3. reids的主从复制是怎么实现的redis的集群模式是如何实现的呢redis的key是如何寻址的啊?
4. 使用redis如何设计分布式锁?使用zk可以吗?如何实现啊这两种哪个效率更高啊??
5. 知道redis的持久化吗都有什么缺点优点啊? ?具体底层实现呢?
6. redis过期策略都有哪些LRU 写一下java版本的代码吧??

## 分库分表 ##
1. 如何设计可以动态扩容缩容的分库分表方案?
2. 用过哪些分库分表中间件，有啥优点和缺点?讲一下你了解的分库分表中间件的底层实现原理?
3. 我现在有一个未分库分表的系统，以后系统需分库分表，如何设计，让未分库分表的系统动态切换到分库分表的系统上???TCC? 那若出现网络原因，网络连不通怎么办啊???
4. 分布式事务知道吗? 你们怎么解决的?
5. 为什么要分库分表啊???
6. 分布式寻址方式都有哪些算法知道一致性hash吗?手写一下java实现代码??你若userId取摸分片，那我要查一段连续时间里的数据怎么办???
7. 如何解决分库分表主键问题有什么实现方案??

## 数据库 ##
1. 使用mysq1索引都有哪些原则? ?索引什么数据结构? 3+tree 和B tree 什么区别?
2. mysq1有哪些存储引擎啊?都有啥区别? 要详细!
3. 设计高并发系统数据库层面该怎么设计??数据库锁有哪些类型?如何实现呀?
4. 数据库事务有哪些?